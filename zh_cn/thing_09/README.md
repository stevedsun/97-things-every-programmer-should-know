# 责怪别人前先检查自己的代码

开发人员——我们所有人！——经常难以相信我们自己的代码是错误的。这很不可能，因此，这一次，肯定是编译器出了问题。

然而，事实上，代码由编译器、解释器、操作系统、应用服务器、数据库、内存管理器或任何其他系统软件的错误造成的情况非常（非常）少。是的，这些错误存在，但它们比我们想象的要少得多。

我曾经遇到过一次编译器错误优化掉了循环变量的问题，但是我想象中的编译器或操作系统出现错误的情况要多得多。在这个过程中，我浪费了很多时间、支持时间和管理时间，最后每次都觉得自己有些傻。

假设工具被广泛使用、成熟，并在各种技术堆栈中使用，就没有理由怀疑其质量。当然，如果这个工具是早期版本、只被全球少数人使用的工具，或者是一个很少下载的、版本为0.1的开源软件，那么有理由怀疑该软件。（同样，商业软件的alpha版本可能会受到怀疑。）

鉴于编译器错误的罕见，你最好把时间和精力投入到查找代码中的错误而不是证明编译器错误上。所有常规的调试建议都适用，所以要隔离问题，取消调用，使用测试环绕它；检查调用约定、共享库和版本号；向其他人解释它；注意堆栈损坏和变量类型不匹配；在不同的计算机和不同的构建配置上尝试代码，例如调试和发布。

质疑自己和他人的假设。来自不同供应商的工具可能内置有不同的假设，同一供应商的不同工具也可能存在假设。

当别人报告一个你无法重现的问题时，去看看他们在做什么。他们可能正在做你从未想到过的事情，或者按照不同的顺序进行操作。

作为一个个人规则，如果我有一个无法确定的错误，并且我开始认为是编译器的问题，那么就是查找堆栈损坏的时候了。如果添加跟踪代码使问题移动，那么这一点尤其重要。

多线程问题是导致 Bug 变得复杂且难以调试的另一个源头。在系统是多线程的情况下，遵循简单代码的建议更加重要。不能依赖调试和单元测试来一致地找出此类 Bug，因此设计的简单性至关重要。

因此，在你急于指责编译器之前，请记住福尔摩斯的建议：“当你排除了不可能的，无论剩下的是多么不可能，那必定是真相。” 并且选择它而不是 Dirk Gently 的建议：“当你排除了不可能的，无论剩下的是多么不可能，那必定是真相。”

By [Allan Kelly](http://programmer.97things.oreilly.com/wiki/index.php/Allan_Kelly)
